# 商品服务 (Product Service)

商品服务是 Shop 电商系统的核心服务之一，负责商品信息管理、分类、品牌、商品搜索、轮播图等功能，为电商平台提供完整的商品数据支持。

## 目录

1. [功能概述](#1-功能概述)
2. [架构设计](#2-架构设计)
3. [数据模型](#3-数据模型)
4. [API 接口说明](#4-api-接口说明)
5. [业务流程](#5-业务流程)
6. [代码结构](#6-代码结构)
7. [搜索功能实现](#7-搜索功能实现)
8. [缓存策略](#8-缓存策略)
9. [数据同步机制](#9-数据同步机制)
10. [安全机制](#10-安全机制)
11. [性能优化](#11-性能优化)
12. [gRPC 服务实现](#12-grpc-服务实现)

## 1. 功能概述

商品服务提供以下核心功能：

- **商品管理**：

  - 添加、修改、删除商品信息
  - 商品上下架管理
  - 商品属性和 SKU 管理
  - 商品图片管理
  - 商品详情富文本内容管理

- **商品分类**：

  - 多级分类管理
  - 分类导航
  - 分类推荐商品

- **品牌管理**：

  - 品牌的 CRUD 操作
  - 品牌推荐和排序
  - 品牌专区管理

- **商品搜索**：

  - 基于 ElasticSearch 的全文搜索
  - 搜索关键词推荐
  - 搜索结果过滤与排序
  - 搜索热词统计

- **营销展示**：

  - 首页轮播图管理
  - 新品推荐
  - 热销商品
  - 限时特惠

- **关联关系管理**：
  - 品牌与分类的多对多关系
  - 商品与分类的关联
  - 商品间的关联推荐

## 2. 架构设计

商品服务采用领域驱动设计(DDD)和微服务架构，将商品领域按业务功能划分为多个子域，实现高内聚低耦合的系统设计。

### 2.1 系统架构图

```
┌──────────────────────────────────────────────────────────┐
│                    商品服务 (Product Service)             │
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │   商品管理    │  │   分类管理   │  │   品牌管理   │    │
│  │    模块      │  │    模块      │  │    模块      │    │
│  └───────┬──────┘  └───────┬──────┘  └───────┬──────┘    │
│          │                 │                 │           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  轮播图管理  │  │  搜索引擎    │  │  数据同步    │    │
│  │    模块      │  │    模块      │  │    模块      │    │
│  └───────┬──────┘  └───────┬──────┘  └───────┬──────┘    │
│          │                 │                 │           │
│          └─────────────────┼─────────────────┘           │
│                            │                             │
└────────────────────────────┼─────────────────────────────┘
                             │
     ┌─────────────────────────────────────────────┐
     │                                             │
┌────▼─────┐  ┌────────────┐  ┌─────────┐  ┌──────▼───────┐
│  MySQL   │  │  Redis     │  │  OSS    │  │ ElasticSearch │
│(主数据库) │  │ (缓存)     │  │(图片存储)│  │ (搜索引擎)   │
└──────────┘  └────────────┘  └─────────┘  └──────────────┘
```

### 2.2 领域模型

商品服务的核心领域模型：

```
┌─────────────────┐       ┌─────────────────┐
│     Product     │       │     Category    │
│  (商品聚合根)    │◄──┐   │  (分类聚合根)   │
└─────────────────┘   │   └─────────────────┘
        △             │            △
        │             │            │
┌─────────────────┐   │   ┌─────────────────┐
│    ProductSKU   │   │   │  CategoryBrand  │
│  (商品SKU实体)   │   │   │  (分类品牌关系) │
└─────────────────┘   │   └────────┬────────┘
                      │            │
┌─────────────────┐   │   ┌─────────────────┐
│ ProductAttribute│   │   │      Brand      │
│  (商品属性实体)  │   └───┤   (品牌聚合根)  │
└─────────────────┘       └─────────────────┘
```

## 2. 数据模型

商品服务的主要数据模型包括：

### 2.1 商品表 (Goods)

```sql
CREATE TABLE `goods` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `category_id` int(11) NOT NULL COMMENT '分类ID',
  `brands_id` int(11) NOT NULL COMMENT '品牌ID',
  `on_sale` tinyint(1) DEFAULT 1 COMMENT '是否上架',
  `ship_free` tinyint(1) DEFAULT 1 COMMENT '是否免运费',
  `is_new` tinyint(1) DEFAULT 0 COMMENT '是否新品',
  `is_hot` tinyint(1) DEFAULT 0 COMMENT '是否热销',
  `name` varchar(100) NOT NULL COMMENT '商品名称',
  `goods_sn` varchar(50) DEFAULT '' COMMENT '商品编号',
  `click_num` int(11) DEFAULT 0 COMMENT '点击数',
  `sold_num` int(11) DEFAULT 0 COMMENT '销量',
  `fav_num` int(11) DEFAULT 0 COMMENT '收藏数',
  `market_price` float DEFAULT 0 COMMENT '市场价',
  `shop_price` float DEFAULT 0 COMMENT '本店价格',
  `goods_brief` varchar(255) DEFAULT '' COMMENT '商品简短描述',
  `goods_desc` text COMMENT '商品详情',
  `goods_front_image` varchar(255) DEFAULT '' COMMENT '商品封面图',
  `is_deleted` tinyint(1) DEFAULT 0 COMMENT '是否已删除',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_category_id` (`category_id`),
  INDEX `idx_brands_id` (`brands_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2.2 分类表 (Category)

```sql
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '分类名称',
  `parent_category_id` int(11) DEFAULT 0 COMMENT '父分类ID',
  `level` int(11) DEFAULT 1 COMMENT '分类级别',
  `is_tab` tinyint(1) DEFAULT 0 COMMENT '是否显示在首页tab',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_parent_id` (`parent_category_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2.3 品牌表 (Brands)

```sql
CREATE TABLE `brands` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '品牌名称',
  `logo` varchar(255) DEFAULT '' COMMENT '品牌logo',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2.4 品牌分类关系表 (GoodsCategoryBrand)

```sql
CREATE TABLE `goods_category_brand` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `category_id` int(11) NOT NULL COMMENT '分类ID',
  `brands_id` int(11) NOT NULL COMMENT '品牌ID',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_category_brand` (`category_id`, `brands_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2.5 轮播图表 (Banner)

```sql
CREATE TABLE `banner` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `image` varchar(255) NOT NULL COMMENT '轮播图片地址',
  `url` varchar(255) DEFAULT '' COMMENT '跳转链接',
  `index` int(11) DEFAULT 0 COMMENT '排序索引',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 3. API 接口说明

商品服务的主要 gRPC 接口包括：

### 3.1 商品相关接口

```protobuf
// 商品列表
rpc GoodsList(GoodsFilterRequest) returns (GoodsListResponse);

// 批量获取商品信息
rpc BatchGetGoods(BatchGoodsIdInfo) returns (GoodsListResponse);

// 获取商品详情
rpc GetGoodsDetail(GoodInfoRequest) returns (GoodsInfoResponse);

// 创建商品
rpc CreateGoods(CreateGoodsInfo) returns (GoodsInfoResponse);

// 更新商品
rpc UpdateGoods(CreateGoodsInfo) returns (google.protobuf.Empty);

// 删除商品
rpc DeleteGoods(DeleteGoodsInfo) returns (google.protobuf.Empty);
```

### 3.2 分类相关接口

```protobuf
// 获取所有分类
rpc GetAllCategorysList(google.protobuf.Empty) returns (CategoryListResponse);

// 获取子分类
rpc GetSubCategory(CategoryListRequest) returns (SubCategoryListResponse);

// 创建分类
rpc CreateCategory(CategoryInfoRequest) returns (CategoryInfoResponse);

// 删除分类
rpc DeleteCategory(DeleteCategoryRequest) returns (google.protobuf.Empty);

// 更新分类
rpc UpdateCategory(CategoryInfoRequest) returns (google.protobuf.Empty);
```

### 3.3 品牌相关接口

```protobuf
// 品牌列表
rpc BrandList(BrandFilterRequest) returns (BrandListResponse);

// 创建品牌
rpc CreateBrand(BrandRequest) returns (BrandInfoResponse);

// 删除品牌
rpc DeleteBrand(BrandRequest) returns (google.protobuf.Empty);

// 更新品牌
rpc UpdateBrand(BrandRequest) returns (google.protobuf.Empty);
```

### 3.4 轮播图相关接口

```protobuf
// 轮播图列表
rpc BannerList(google.protobuf.Empty) returns (BannerListResponse);

// 创建轮播图
rpc CreateBanner(BannerRequest) returns (BannerResponse);

// 删除轮播图
rpc DeleteBanner(BannerRequest) returns (google.protobuf.Empty);

// 更新轮播图
rpc UpdateBanner(BannerRequest) returns (google.protobuf.Empty);
```

### 3.5 品牌分类关联接口

```protobuf
// 分类品牌列表
rpc CategoryBrandList(CategoryBrandFilterRequest) returns (CategoryBrandListResponse);

// 获取品牌的分类
rpc GetCategoryBrandList(CategoryInfoRequest) returns (BrandListResponse);

// 创建品牌分类关联
rpc CreateCategoryBrand(CategoryBrandRequest) returns (CategoryBrandResponse);

// 删除品牌分类关联
rpc DeleteCategoryBrand(CategoryBrandRequest) returns (google.protobuf.Empty);

// 更新品牌分类关联
rpc UpdateCategoryBrand(CategoryBrandRequest) returns (google.protobuf.Empty);
```

## 4. 业务流程

### 4.1 商品添加流程

1. 管理员通过后台提交商品信息（基本信息、分类、品牌等）
2. API 层验证参数合法性
3. 调用领域服务的 CreateGoods 接口
4. 领域服务保存商品信息到仓储
5. 通知搜索服务更新商品索引
6. 返回商品信息

### 4.2 商品搜索流程

1. 用户提交搜索关键词
2. API 层验证参数
3. 调用搜索服务接口查询匹配的商品
4. 获取商品列表并补充详细信息
5. 返回商品列表及分页信息

### 4.3 品牌分类关联流程

1. 管理员选择品牌和分类进行关联
2. API 层验证参数合法性
3. 调用领域服务创建关联关系
4. 保存关联信息到数据库
5. 返回关联信息

### 4.4 轮播图管理流程

1. 管理员上传轮播图片并配置相关信息
2. API 层验证参数合法性
3. 调用轮播图服务保存信息
4. 图片上传至对象存储服务
5. 保存轮播图信息到数据库
6. 返回轮播图信息

## 5. 代码结构

商品服务采用整洁架构和领域驱动设计(DDD)原则，代码结构如下：

```
backend/product/
├── cmd/                # 应用入口
│   └── main.go         # 服务启动入口
├── configs/            # 服务特定配置
│   ├── config.go       # 配置加载
│   ├── config.yaml     # 配置文件
│   └── elasticsearch.yaml # ES配置
├── api/                # API定义
│   ├── common/         # 通用定义
│   └── proto/          # Protocol Buffers
│       └── product.proto # 商品服务接口定义
├── internal/           # 内部实现
│   ├── domain/         # 领域模型
│   │   ├── entity/     # 实体定义
│   │   │   ├── product.go     # 商品实体
│   │   │   ├── category.go    # 分类实体
│   │   │   ├── brand.go       # 品牌实体
│   │   │   └── banner.go      # 轮播图实体
│   │   ├── valueobject/ # 值对象
│   │   │   ├── price.go       # 价格值对象
│   │   │   └── image.go       # 图片值对象
│   │   └── event/       # 领域事件
│   │       └── product_events.go # 商品相关事件
│   ├── repository/     # 数据仓储层
│   │   ├── product_repository.go # 仓储接口
│   │   ├── product_repository_impl.go # 实现
│   │   ├── cache/      # 缓存实现
│   │   │   └── redis_cache.go # Redis缓存
│   │   └── dao/        # 数据访问对象
│   │       ├── product_dao.go # 商品DAO
│   │       ├── category_dao.go # 分类DAO
│   │       ├── brand_dao.go   # 品牌DAO
│   │       └── banner_dao.go  # 轮播图DAO
│   ├── service/        # 业务服务层
│   │   ├── product_service.go   # 商品服务接口
│   │   ├── product_service_impl.go # 商品服务实现
│   │   ├── category_service.go  # 分类服务接口
│   │   ├── category_service_impl.go # 分类服务实现
│   │   ├── brand_service.go     # 品牌服务接口
│   │   ├── brand_service_impl.go # 品牌服务实现
│   │   ├── banner_service.go    # 轮播图服务接口
│   │   └── banner_service_impl.go # 轮播图服务实现
│   └── web/            # Web交互层
│       ├── grpc/       # gRPC服务实现
│       │   └── product_grpc_handler.go # gRPC处理器
│       └── http/       # HTTP服务实现
│           └── product_handler.go # HTTP处理器
├── pkg/                # 服务内共享包
│   ├── util/           # 通用工具
│   │   └── pagination.go # 分页工具
│   ├── search/         # 搜索引擎封装
│   │   └── elasticsearch.go # ES客户端封装
│   ├── middleware/     # 中间件
│   │   └── ratelimit/  # 限流
│   │       └── limiter.go # 限流器
│   └── grpc/           # gRPC相关工具
│       ├── client/     # 客户端工具
│       │   └── conn.go # 连接管理
│       └── server/     # 服务端工具
│           ├── server.go       # 服务器封装
│           └── interceptor.go  # 拦截器
└── script/             # 脚本文件
    └── mysql/          # 数据库脚本
        ├── schema.sql  # 表结构
        └── migrations/ # 数据库迁移
```

## 6. 搜索功能实现

商品服务使用 ElasticSearch 实现全文搜索功能：

### 6.1 索引结构

```json
{
  "mappings": {
    "properties": {
      "id": { "type": "integer" },
      "name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "goods_brief": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "goods_desc": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "category_id": { "type": "integer" },
      "brands_id": { "type": "integer" },
      "on_sale": { "type": "boolean" },
      "ship_free": { "type": "boolean" },
      "is_new": { "type": "boolean" },
      "is_hot": { "type": "boolean" },
      "shop_price": { "type": "float" },
      "market_price": { "type": "float" }
    }
  }
}
```

### 6.2 数据同步策略

商品数据的 MySQL 到 ElasticSearch 同步采用以下策略：

1. 初始化同步：启动时从 MySQL 全量导入到 ES
2. 增量同步：商品创建、更新、删除时通过事件消息同步更新 ES
3. 定时任务：定期全量同步，确保数据一致性

### 6.3 搜索服务实现

```go
// internal/search/elasticsearch/product_search.go 示例
package elasticsearch

import (
    "context"
    "encoding/json"
    "shop/product/domain/entity"
    "shop/product/domain/repository"
    "github.com/olivere/elastic/v7"
)

type ProductSearchRepositoryImpl struct {
    client *elastic.Client
    index  string
}

func NewProductSearchRepository(client *elastic.Client) repository.ProductSearchRepository {
    return &ProductSearchRepositoryImpl{
        client: client,
        index:  "products",
    }
}

func (r *ProductSearchRepositoryImpl) Search(ctx context.Context, keyword string, filters map[string]interface{}, page, size int) ([]*entity.Product, int64, error) {
    query := elastic.NewBoolQuery()

    // 关键词搜索
    if keyword != "" {
        multiMatchQuery := elastic.NewMultiMatchQuery(keyword, "name", "goods_brief", "goods_desc")
            .Type("best_fields")
            .Fuzziness("AUTO")
        query = query.Must(multiMatchQuery)
    }

    // 过滤条件
    for field, value := range filters {
        query = query.Filter(elastic.NewTermQuery(field, value))
    }

    // 执行搜索
    searchResult, err := r.client.Search().
        Index(r.index).
        Query(query).
        From((page - 1) * size).
        Size(size).
        Do(ctx)

    if err != nil {
        return nil, 0, err
    }

    // 解析结果
    products := make([]*entity.Product, 0)
    for _, hit := range searchResult.Hits.Hits {
        var product entity.Product
        if err := json.Unmarshal(hit.Source, &product); err != nil {
            continue
        }
        products = append(products, &product)
    }

    return products, searchResult.TotalHits(), nil
}

// 其他搜索方法实现...
```

## 7. 搜索功能实现

商品服务的搜索功能基于 ElasticSearch 实现，具有高性能、高可用和丰富的搜索特性。

### 7.1 搜索架构

```
┌──────────────────┐     ┌───────────────────┐    ┌───────────────────┐
│  商品数据变更    │────►│  数据同步服务     │───►│  ElasticSearch    │
│  (MySQL)         │     │  (Logstash/MQ)    │    │  (搜索引擎)       │
└──────────────────┘     └───────────────────┘    └─────────┬─────────┘
                                                            │
┌──────────────────┐     ┌───────────────────┐    ┌─────────▼─────────┐
│  用户搜索请求    │────►│  搜索服务API      │◄───┤  搜索结果处理    │
│  (前端/API网关)  │     │  (商品服务)       │    │  (过滤/排序/聚合) │
└──────────────────┘     └───────────────────┘    └───────────────────┘
```

### 7.2 索引结构设计

商品搜索索引包含以下字段：

```json
{
  "mappings": {
    "properties": {
      "id": { "type": "keyword" },
      "name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "goods_brief": { "type": "text", "analyzer": "ik_max_word" },
      "goods_desc": { "type": "text", "analyzer": "ik_max_word" },
      "category_id": { "type": "integer" },
      "category_name": { "type": "keyword" },
      "brands_id": { "type": "integer" },
      "brand_name": { "type": "keyword" },
      "on_sale": { "type": "boolean" },
      "ship_free": { "type": "boolean" },
      "is_new": { "type": "boolean" },
      "is_hot": { "type": "boolean" },
      "goods_front_image": { "type": "keyword" },
      "market_price": { "type": "float" },
      "shop_price": { "type": "float" },
      "sold_num": { "type": "integer" },
      "click_num": { "type": "integer" },
      "fav_num": { "type": "integer" },
      "created_at": { "type": "date" },
      "updated_at": { "type": "date" },
      "tags": { "type": "keyword" },
      "specs": {
        "type": "nested",
        "properties": {
          "name": { "type": "keyword" },
          "value": { "type": "keyword" }
        }
      }
    }
  }
}
```

### 7.3 数据同步策略

商品服务采用多种方式确保 MySQL 和 ElasticSearch 之间的数据同步：

1. **全量同步**：系统初始化或重建索引时，通过批量导入全部商品数据
2. **增量同步**：通过 Binlog 或消息队列，实时捕获商品数据变更并更新 ES
3. **定时同步**：定期执行同步任务，修复可能的数据不一致问题

```go
// 增量同步实现示例
func (s *productService) syncToElasticSearch(ctx context.Context, product *model.Product) error {
    // 构建ES文档
    doc := map[string]interface{}{
        "id":              product.ID,
        "name":            product.Name,
        "goods_brief":     product.GoodsBrief,
        "goods_desc":      product.GoodsDesc,
        "category_id":     product.CategoryID,
        "brands_id":       product.BrandsID,
        "on_sale":         product.OnSale,
        "ship_free":       product.ShipFree,
        "is_new":          product.IsNew,
        "is_hot":          product.IsHot,
        "goods_front_image": product.GoodsFrontImage,
        "market_price":    product.MarketPrice,
        "shop_price":      product.ShopPrice,
        "sold_num":        product.SoldNum,
        "click_num":       product.ClickNum,
        "fav_num":         product.FavNum,
        "created_at":      product.CreatedAt,
        "updated_at":      product.UpdatedAt,
    }

    // 获取分类名称
    category, err := s.categoryRepo.GetCategoryByID(ctx, product.CategoryID)
    if err == nil && category != nil {
        doc["category_name"] = category.Name
    }

    // 获取品牌名称
    brand, err := s.brandRepo.GetBrandByID(ctx, product.BrandsID)
    if err == nil && brand != nil {
        doc["brand_name"] = brand.Name
    }

    // 获取规格信息
    specs, err := s.productRepo.GetProductSpecs(ctx, product.ID)
    if err == nil && len(specs) > 0 {
        var specDocs []map[string]interface{}
        for _, spec := range specs {
            specDocs = append(specDocs, map[string]interface{}{
                "name":  spec.Name,
                "value": spec.Value,
            })
        }
        doc["specs"] = specDocs
    }

    // 同步到ES
    _, err = s.esClient.Index().
        Index("products").
        Id(strconv.Itoa(product.ID)).
        BodyJson(doc).
        Refresh("true").
        Do(ctx)

    return err
}
```

### 7.4 搜索功能实现

商品搜索功能实现了以下特性：

#### 7.4.1 分词与搜索优化

- 使用 IK 分词器支持中文分词
- 采用多字段搜索，提高召回率
- 支持拼音搜索和同义词搜索

```go
// 搜索请求示例
func (s *productService) SearchProducts(ctx context.Context, req *proto.SearchRequest) (*proto.ProductListResponse, error) {
    // 构建搜索查询
    query := elastic.NewBoolQuery()

    // 关键词搜索
    if req.Keyword != "" {
        query.Must(elastic.NewMultiMatchQuery(req.Keyword,
            "name^3", "goods_brief^2", "goods_desc", "brand_name", "category_name").
            Type("best_fields").
            Fuzziness("AUTO"))
    }

    // 分类过滤
    if req.CategoryId > 0 {
        query.Filter(elastic.NewTermQuery("category_id", req.CategoryId))
    }

    // 品牌过滤
    if req.BrandId > 0 {
        query.Filter(elastic.NewTermQuery("brands_id", req.BrandId))
    }

    // 价格区间过滤
    if req.MinPrice > 0 || req.MaxPrice > 0 {
        priceQuery := elastic.NewRangeQuery("shop_price")
        if req.MinPrice > 0 {
            priceQuery.Gte(req.MinPrice)
        }
        if req.MaxPrice > 0 {
            priceQuery.Lte(req.MaxPrice)
        }
        query.Filter(priceQuery)
    }

    // 只显示在售商品
    query.Filter(elastic.NewTermQuery("on_sale", true))

    // 排序
    sortField := "updated_at"
    sortAsc := false

    switch req.OrderBy {
    case proto.OrderByEnum_PRICE_ASC:
        sortField = "shop_price"
        sortAsc = true
    case proto.OrderByEnum_PRICE_DESC:
        sortField = "shop_price"
        sortAsc = false
    case proto.OrderByEnum_SOLD_NUM:
        sortField = "sold_num"
        sortAsc = false
    case proto.OrderByEnum_CLICK_NUM:
        sortField = "click_num"
        sortAsc = false
    }

    // 分页
    from := (req.PageNum - 1) * req.PageSize
    size := req.PageSize

    // 执行搜索
    result, err := s.esClient.Search().
        Index("products").
        Query(query).
        Sort(sortField, sortAsc).
        From(int(from)).
        Size(int(size)).
        Do(ctx)

    if err != nil {
        return nil, err
    }

    // 处理搜索结果
    // ...

    return response, nil
}
```

#### 7.4.2 搜索结果优化

- **相关性排序**：基于 TF-IDF 算法计算文档相关性
- **热门度融合**：将商品热度（点击量、销量）与相关性得分融合
- **个性化排序**：根据用户历史行为进行结果个性化排序
- **多样性保证**：避免相似商品扎堆出现，提升用户体验

### 7.5 搜索统计与优化

- **热门搜索词统计**：记录和分析用户搜索词，识别热门搜索需求
- **搜索转化分析**：分析搜索结果的点击和购买转化率
- **零结果搜索分析**：识别无结果搜索词，进行同义词扩展
- **搜索建议优化**：根据热门搜索和转化率自动优化搜索建议

## 8. 缓存策略

商品服务实现了多层缓存策略，提升系统性能和用户体验。

### 8.1 缓存层次

```
┌──────────────────────────────────────────┐
│            客户端缓存 (浏览器/App)        │ ◄── 静态资源、商品图片
└────────────────────────┬─────────────────┘
                         │
┌────────────────────────▼─────────────────┐
│            CDN 缓存                       │ ◄── 商品图片、详情页面
└────────────────────────┬─────────────────┘
                         │
┌────────────────────────▼─────────────────┐
│            API 网关缓存                   │ ◄── 首页商品、热门商品
└────────────────────────┬─────────────────┘
                         │
┌────────────────────────▼─────────────────┐
│            Redis 分布式缓存               │ ◄── 商品详情、分类列表
└────────────────────────┬─────────────────┘
                         │
┌────────────────────────▼─────────────────┐
│            本地缓存 (服务实例内)          │ ◄── 配置信息、常用数据
└────────────────────────┬─────────────────┘
                         │
┌────────────────────────▼─────────────────┐
│            数据库 (MySQL)                 │ ◄── 持久化存储
└──────────────────────────────────────────┘
```

### 8.2 缓存策略

- **热点数据缓存**：热门商品、分类、品牌等数据优先缓存
- **计算结果缓存**：复杂查询和统计结果进行缓存
- **按更新频率分层**：根据数据更新频率设置不同的缓存过期时间
- **预加载机制**：系统启动或大促前预加载核心数据到缓存

## 9. gRPC 服务实现

商品服务通过 gRPC 向其他微服务提供数据访问能力，实现高效的服务间通信。

### 9.1 协议定义

以下是商品服务的核心 Protocol Buffers 定义：

```protobuf
syntax = "proto3";
package proto;
option go_package = "shop/goods/proto";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// 商品服务接口定义
service GoodsService {
  // 商品管理接口
  rpc GoodsList(GoodsFilterRequest) returns (GoodsListResponse);
  rpc BatchGetGoods(BatchGoodsIdInfo) returns (GoodsListResponse);
  rpc GetGoodsDetail(GoodInfoRequest) returns (GoodsInfoResponse);
  rpc CreateGoods(CreateGoodsInfo) returns (GoodsInfoResponse);
  rpc UpdateGoods(CreateGoodsInfo) returns (google.protobuf.Empty);
  rpc DeleteGoods(DeleteGoodsInfo) returns (google.protobuf.Empty);

  // 分类管理接口
  rpc GetAllCategorysList(google.protobuf.Empty) returns (CategoryListResponse);
  rpc GetSubCategory(CategoryListRequest) returns (SubCategoryListResponse);
  rpc CreateCategory(CategoryInfoRequest) returns (CategoryInfoResponse);
  rpc DeleteCategory(DeleteCategoryInfo) returns (google.protobuf.Empty);
  rpc UpdateCategory(CategoryInfoRequest) returns (google.protobuf.Empty);

  // 品牌管理接口
  rpc BrandList(BrandFilterRequest) returns (BrandListResponse);
  rpc CreateBrand(BrandInfoRequest) returns (BrandInfoResponse);
  rpc DeleteBrand(BrandInfoRequest) returns (google.protobuf.Empty);
  rpc UpdateBrand(BrandInfoRequest) returns (google.protobuf.Empty);

  // 轮播图管理接口
  rpc BannerList(google.protobuf.Empty) returns (BannerListResponse);
  rpc CreateBanner(BannerRequest) returns (BannerResponse);
  rpc DeleteBanner(BannerRequest) returns (google.protobuf.Empty);
  rpc UpdateBanner(BannerRequest) returns (google.protobuf.Empty);

  // 商品搜索接口
  rpc SearchGoods(GoodsSearchRequest) returns (GoodsSearchResponse);
}

// 商品信息消息定义
message GoodsInfoResponse {
  int32 id = 1;
  string name = 2;
  string goods_sn = 3;
  int32 stocks = 4;
  float market_price = 5;
  float shop_price = 6;
  string goods_brief = 7;
  string goods_desc = 8;
  bool ship_free = 9;
  repeated string images = 10;
  repeated string desc_images = 11;
  string goods_front_image = 12;
  bool is_new = 13;
  bool is_hot = 14;
  bool on_sale = 15;
  int32 category_id = 16;
  int32 brand_id = 17;
  google.protobuf.Timestamp add_time = 18;
  CategoryBriefInfoResponse category = 19;
  BrandInfoResponse brand = 20;
}

// 其他消息定义省略...
```

### 9.2 服务端实现

商品服务的 gRPC 实现采用了领域驱动设计思想，将领域逻辑与 gRPC 处理分离：

```go
package server

import (
	"context"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
	"shop/goods/domain/service"
	"shop/goods/proto"
)

// GoodsServer 商品服务 gRPC 实现
type GoodsServer struct {
	proto.UnimplementedGoodsServiceServer
	goodsService service.GoodsService
	categoryService service.CategoryService
	brandService service.BrandService
	bannerService service.BannerService
	searchService service.SearchService
}

// NewGoodsServer 创建商品服务实例
func NewGoodsServer(
	goodsService service.GoodsService,
	categoryService service.CategoryService,
	brandService service.BrandService,
	bannerService service.BannerService,
	searchService service.SearchService,
) *GoodsServer {
	return &GoodsServer{
		goodsService: goodsService,
		categoryService: categoryService,
		brandService: brandService,
		bannerService: bannerService,
		searchService: searchService,
	}
}

// GetGoodsDetail 获取商品详情实现
func (s *GoodsServer) GetGoodsDetail(ctx context.Context, req *proto.GoodInfoRequest) (*proto.GoodsInfoResponse, error) {
	// 参数验证
	if req.Id <= 0 {
		return nil, status.Error(codes.InvalidArgument, "商品ID必须大于0")
	}

	// 调用领域服务
	goods, err := s.goodsService.GetGoodsById(ctx, int(req.Id))
	if err != nil {
		return nil, status.Errorf(codes.Internal, "获取商品失败: %v", err)
	}
	if goods == nil {
		return nil, status.Error(codes.NotFound, "商品不存在")
	}

	// 转换为响应对象
	return convertToGoodsInfoResponse(goods), nil
}

// SearchGoods 商品搜索实现
func (s *GoodsServer) SearchGoods(ctx context.Context, req *proto.GoodsSearchRequest) (*proto.GoodsSearchResponse, error) {
	// 参数验证
	if req.Keywords == "" && req.CategoryId == 0 && req.BrandId == 0 {
		return nil, status.Error(codes.InvalidArgument, "搜索参数不能全为空")
	}

	// 调用搜索服务
	result, err := s.searchService.SearchGoods(ctx, &service.SearchParams{
		Keywords:   req.Keywords,
		CategoryID: int(req.CategoryId),
		BrandID:    int(req.BrandId),
		PriceMin:   float64(req.PriceMin),
		PriceMax:   float64(req.PriceMax),
		IsHot:      req.IsHot,
		IsNew:      req.IsNew,
		Pagination: service.Pagination{
			Page:     int(req.Page),
			PageSize: int(req.PageSize),
		},
	})

	if err != nil {
		return nil, status.Errorf(codes.Internal, "搜索商品失败: %v", err)
	}

	// 构造搜索响应
	response := &proto.GoodsSearchResponse{
		Total: int32(result.Total),
		Pages: int32(result.Pages),
		Goods: make([]*proto.GoodsInfoResponse, 0, len(result.Goods)),
	}

	for _, g := range result.Goods {
		response.Goods = append(response.Goods, convertToGoodsInfoResponse(g))
	}

	return response, nil
}

// 其他接口实现省略...
```

### 9.3 客户端调用示例

其他微服务通过客户端调用商品服务的 gRPC 接口：

```go
package client

import (
	"context"
	"google.golang.org/grpc"
	"shop/goods/proto"
)

// GoodsServiceClient 商品服务客户端
type GoodsServiceClient struct {
	client proto.GoodsServiceClient
}

// NewGoodsServiceClient 创建商品服务客户端
func NewGoodsServiceClient(conn *grpc.ClientConn) *GoodsServiceClient {
	return &GoodsServiceClient{
		client: proto.NewGoodsServiceClient(conn),
	}
}

// GetGoodsDetail 获取商品详情
func (c *GoodsServiceClient) GetGoodsDetail(ctx context.Context, id int32) (*proto.GoodsInfoResponse, error) {
	return c.client.GetGoodsDetail(ctx, &proto.GoodInfoRequest{Id: id})
}

// BatchGetGoods 批量获取商品信息
func (c *GoodsServiceClient) BatchGetGoods(ctx context.Context, ids []int32) ([]*proto.GoodsInfoResponse, error) {
	resp, err := c.client.BatchGetGoods(ctx, &proto.BatchGoodsIdInfo{
		Id: ids,
	})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

// SearchGoods 搜索商品
func (c *GoodsServiceClient) SearchGoods(ctx context.Context, params *SearchParams) (*SearchResult, error) {
	req := &proto.GoodsSearchRequest{
		Keywords:  params.Keywords,
		CategoryId: int32(params.CategoryID),
		BrandId:   int32(params.BrandID),
		PriceMin:  float32(params.PriceMin),
		PriceMax:  float32(params.PriceMax),
		IsHot:     params.IsHot,
		IsNew:     params.IsNew,
		Page:      int32(params.Page),
		PageSize:  int32(params.PageSize),
	}

	resp, err := c.client.SearchGoods(ctx, req)
	if err != nil {
		return nil, err
	}

	result := &SearchResult{
		Total: int(resp.Total),
		Pages: int(resp.Pages),
		Goods: make([]*GoodsInfo, 0, len(resp.Goods)),
	}

	for _, g := range resp.Goods {
		result.Goods = append(result.Goods, convertFromProtoGoods(g))
	}

	return result, nil
}
```

### 9.4 gRPC 拦截器实现

商品服务实现了多种 gRPC 拦截器，用于日志记录、监控和错误处理：

```go
package middleware

import (
	"context"
	"github.com/opentracing/opentracing-go"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"time"
)

// LoggingInterceptor 日志拦截器
func LoggingInterceptor(logger *zap.Logger) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		startTime := time.Now()

		// 记录请求信息
		logger.Info("gRPC 请求开始",
			zap.String("method", info.FullMethod),
			zap.Any("request", req),
		)

		// 调用原始处理函数
		resp, err := handler(ctx, req)

		// 记录响应信息
		latency := time.Since(startTime)
		if err != nil {
			logger.Error("gRPC 请求失败",
				zap.String("method", info.FullMethod),
				zap.Duration("latency", latency),
				zap.Error(err),
			)
		} else {
			logger.Info("gRPC 请求完成",
				zap.String("method", info.FullMethod),
				zap.Duration("latency", latency),
			)
		}

		return resp, err
	}
}

// TracingInterceptor 分布式追踪拦截器
func TracingInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		// 从上下文中获取 span
		span := opentracing.SpanFromContext(ctx)
		if span == nil {
			// 如果没有 span，创建一个新的
			tracer := opentracing.GlobalTracer()
			span, ctx = opentracing.StartSpanFromContextWithTracer(ctx, tracer, info.FullMethod)
			defer span.Finish()
		}

		// 在 span 中记录请求信息
		span.SetTag("method", info.FullMethod)

		// 调用原始处理函数
		resp, err := handler(ctx, req)

		// 记录错误信息
		if err != nil {
			span.SetTag("error", true)
			span.SetTag("error.message", err.Error())
			if s, ok := status.FromError(err); ok {
				span.SetTag("error.code", s.Code())
			}
		}

		return resp, err
	}
}

// ErrorHandlingInterceptor 错误处理拦截器
func ErrorHandlingInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		resp, err := handler(ctx, req)

		if err != nil {
			// 如果已经是 gRPC 状态错误，直接返回
			if _, ok := status.FromError(err); ok {
				return resp, err
			}

			// 将普通错误转换为 gRPC 状态错误
			return resp, status.Error(codes.Internal, err.Error())
		}

		return resp, nil
	}
}
```

### 9.5 gRPC 服务注册与发现

商品服务通过 Consul 实现服务注册与发现：

```go
package registry

import (
	"fmt"
	"github.com/hashicorp/consul/api"
	"google.golang.org/grpc"
	"log"
	"net"
)

// ConsulRegistry Consul 服务注册器
type ConsulRegistry struct {
	client       *api.Client
	registration *api.AgentServiceRegistration
}

// NewConsulRegistry 创建 Consul 服务注册器
func NewConsulRegistry(addr string) (*ConsulRegistry, error) {
	config := api.DefaultConfig()
	config.Address = addr

	client, err := api.NewClient(config)
	if err != nil {
		return nil, err
	}

	return &ConsulRegistry{
		client: client,
	}, nil
}

// Register 注册 gRPC 服务
func (r *ConsulRegistry) Register(serviceID, serviceName string, port int, tags []string) error {
	address, err := getLocalIP()
	if err != nil {
		return err
	}

	// 创建健康检查
	check := &api.AgentServiceCheck{
		GRPC:                           fmt.Sprintf("%s:%d", address, port),
		Interval:                       "10s",
		Timeout:                        "5s",
		DeregisterCriticalServiceAfter: "30s",
	}

	// 创建服务注册信息
	r.registration = &api.AgentServiceRegistration{
		ID:      serviceID,
		Name:    serviceName,
		Tags:    tags,
		Port:    port,
		Address: address,
		Check:   check,
	}

	// 注册服务
	return r.client.Agent().ServiceRegister(r.registration)
}

// Deregister 注销服务
func (r *ConsulRegistry) Deregister() error {
	if r.registration == nil {
		return nil
	}
	return r.client.Agent().ServiceDeregister(r.registration.ID)
}

// 获取本地 IP 地址
func getLocalIP() (string, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "", err
	}
	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String(), nil
			}
		}
	}
	return "", fmt.Errorf("无法获取本地 IP 地址")
}

// StartGRPCServer 启动 gRPC 服务并注册到 Consul
func StartGRPCServer(server *grpc.Server, port int, serviceName, consulAddr string) error {
	// 创建 Consul 注册器
	registry, err := NewConsulRegistry(consulAddr)
	if err != nil {
		return err
	}

	// 生成唯一服务 ID
	serviceID := fmt.Sprintf("%s-%d", serviceName, port)

	// 注册服务
	if err := registry.Register(serviceID, serviceName, port, []string{"grpc"}); err != nil {
		return err
	}

	// 监听端口
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return err
	}

	// 服务关闭时注销
	go func() {
		<-server.StopCh
		if err := registry.Deregister(); err != nil {
			log.Printf("注销服务失败: %v", err)
		}
	}()

	// 启动 gRPC 服务
	log.Printf("启动 gRPC 服务，监听端口：%d", port)
	return server.Serve(lis)
}
```

### 9.6 服务配置与初始化

商品服务的 gRPC 服务器初始化：

```go
package main

import (
	"google.golang.org/grpc"
	"log"
	"os"
	"os/signal"
	"shop/goods/config"
	"shop/goods/domain/service"
	"shop/goods/infra/es"
	"shop/goods/infra/repository"
	"shop/goods/proto"
	"shop/goods/server"
	"shop/goods/server/middleware"
	"shop/goods/server/registry"
	"syscall"
)

func main() {
	// 加载配置
	conf, err := config.LoadConfig("./config")
	if err != nil {
		log.Fatalf("加载配置失败: %v", err)
	}

	// 初始化数据库
	db, err := repository.InitDB(conf.Database)
	if err != nil {
		log.Fatalf("初始化数据库失败: %v", err)
	}

	// 初始化 ES 客户端
	esClient, err := es.NewESClient(conf.ElasticSearch)
	if err != nil {
		log.Fatalf("初始化 ES 客户端失败: %v", err)
	}

	// 初始化日志
	logger := initLogger(conf.Log)

	// 创建拦截器
	loggingInterceptor := middleware.LoggingInterceptor(logger)
	tracingInterceptor := middleware.TracingInterceptor()
	errorHandlingInterceptor := middleware.ErrorHandlingInterceptor()

	// 创建 gRPC 服务器，并添加拦截器
	grpcServer := grpc.NewServer(
		grpc.ChainUnaryInterceptor(
			loggingInterceptor,
			tracingInterceptor,
			errorHandlingInterceptor,
		),
	)

	// 初始化仓储
	goodsRepo := repository.NewGoodsRepository(db)
	categoryRepo := repository.NewCategoryRepository(db)
	brandRepo := repository.NewBrandRepository(db)
	bannerRepo := repository.NewBannerRepository(db)

	// 初始化搜索引擎
	searchEngine := es.NewGoodsSearchEngine(esClient)

	// 初始化领域服务
	goodsService := service.NewGoodsService(goodsRepo, categoryRepo, brandRepo)
	categoryService := service.NewCategoryService(categoryRepo)
	brandService := service.NewBrandService(brandRepo)
	bannerService := service.NewBannerService(bannerRepo)
	searchService := service.NewSearchService(searchEngine, goodsRepo)

	// 创建并注册 gRPC 服务
	goodsServer := server.NewGoodsServer(
		goodsService,
		categoryService,
		brandService,
		bannerService,
		searchService,
	)
	proto.RegisterGoodsServiceServer(grpcServer, goodsServer)

	// 启动 gRPC 服务并注册到 Consul
	go func() {
		if err := registry.StartGRPCServer(
			grpcServer,
			conf.Server.Port,
			conf.Server.Name,
			conf.Consul.Address,
		); err != nil {
			log.Fatalf("启动 gRPC 服务失败: %v", err)
		}
	}()

	// 等待终止信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	// 优雅关闭
	log.Println("正在关闭 gRPC 服务器...")
	grpcServer.GracefulStop()
	log.Println("服务器已关闭")
}
```
