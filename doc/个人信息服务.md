# 个人信息服务 (Profile Service)

个人信息服务是 Shop 电商系统中负责处理用户个性化数据的核心服务，包括用户收藏、地址管理、留言反馈、浏览历史等功能，作为用户服务的功能扩展，提供更完善的个性化用户体验。

## 目录

1. [功能概述](#1-功能概述)
2. [系统架构](#2-系统架构)
3. [数据模型](#3-数据模型)
4. [API 接口说明](#4-api-接口说明)
5. [业务流程](#5-业务流程)
6. [代码结构](#6-代码结构)
7. [技术栈实现](#7-技术栈实现)
8. [数据一致性](#8-数据一致性)
9. [隐私保护机制](#9-隐私保护机制)
10. [安全机制](#10-安全机制)
11. [性能优化](#11-性能优化)

## 1. 功能概述

个人信息服务提供以下核心功能：

- **商品收藏**：

  - 用户对商品的收藏与取消收藏
  - 收藏列表的分页查询与筛选
  - 收藏商品的价格变动提醒
  - 收藏排序和分类管理

- **地址管理**：

  - 用户收货地址的增删改查
  - 默认地址设置
  - 地址智能排序（基于使用频率）
  - 地址有效性验证
  - 地址标签管理（家庭、公司等）

- **用户反馈**：

  - 用户留言、投诉、建议提交
  - 问题跟踪与状态更新
  - 反馈附件上传
  - 反馈回复通知

- **浏览历史**：

  - 记录用户浏览商品历史
  - 提供浏览记录查询与删除
  - 基于浏览历史的个性化推荐

- **用户偏好设置**：
  - 通知偏好设置
  - 隐私设置
  - 界面偏好设置

这些功能不仅丰富了用户的交互体验，还为电商平台提供了用户行为数据分析的基础，助力个性化推荐和精准营销。

## 2. 系统架构

个人信息服务采用微服务架构，与用户服务和商品服务紧密协作，专注于管理用户个性化数据。

### 2.1 系统架构图

```
┌───────────────────────────────────────────────────────────┐
│              个人信息服务 (Profile Service)                │
│                                                           │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐      │
│  │  收藏管理   │   │  地址管理   │   │  反馈管理   │      │
│  │   模块      │   │   模块      │   │   模块      │      │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘      │
│         │                 │                 │             │
│         └─────────────────┼─────────────────┘             │
│                           │                               │
│  ┌─────────────┐   ┌──────▼──────┐   ┌─────────────┐      │
│  │ 浏览历史    │   │  数据访问   │   │ 偏好设置    │      │
│  │  模块       │   │   层        │   │  模块       │      │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘      │
│         │                 │                 │             │
│         └─────────────────┼─────────────────┘             │
└───────────────────────────┼───────────────────────────────┘
                            │
    ┌─────────────────────────────────────────────┐
    │                                             │
┌───▼────┐   ┌────────────┐   ┌─────────┐   ┌─────▼────┐
│ MySQL  │   │  Redis     │   │  MQ     │   │  Cache   │
│(数据库) │   │ (缓存)     │   │(消息队列)│   │(本地缓存)│
└────────┘   └────────────┘   └─────────┘   └──────────┘
```

### 2.2 与其他服务的关系

个人信息服务与其他微服务之间存在以下关键交互：

1. **用户服务**：

   - 用户身份认证与授权
   - 用户基本信息获取
   - 用户状态同步

2. **商品服务**：

   - 收藏商品信息获取
   - 浏览商品信息记录
   - 商品价格变动通知

3. **订单服务**：

   - 默认地址的使用
   - 订单地址的获取和更新

4. **消息服务**：
   - 反馈回复通知
   - 收藏商品价格变动通知

## 3. 数据模型

个人信息服务的主要数据模型包括：

### 3.1 用户收藏表 (UserFav)

```sql
CREATE TABLE `user_fav` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user` int(11) NOT NULL COMMENT '用户ID',
  `goods` int(11) NOT NULL COMMENT '商品ID',
  `category_id` int(11) DEFAULT NULL COMMENT '商品分类ID',
  `remark` varchar(255) DEFAULT NULL COMMENT '收藏备注',
  `price_when_fav` decimal(10,2) DEFAULT NULL COMMENT '收藏时价格',
  `notification` tinyint(1) DEFAULT 0 COMMENT '价格变动通知',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_goods` (`user`, `goods`),
  INDEX `idx_user_category` (`user`, `category_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.2 用户地址表 (Address)

```sql
CREATE TABLE `address` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user` int(11) NOT NULL COMMENT '用户ID',
  `province` varchar(20) NOT NULL COMMENT '省',
  `city` varchar(20) NOT NULL COMMENT '市',
  `district` varchar(20) NOT NULL COMMENT '区/县',
  `address` varchar(100) NOT NULL COMMENT '详细地址',
  `signer_name` varchar(50) NOT NULL COMMENT '收货人姓名',
  `signer_mobile` varchar(11) NOT NULL COMMENT '收货人手机号',
  `is_default` tinyint(1) DEFAULT 0 COMMENT '是否默认地址',
  `label` varchar(20) DEFAULT NULL COMMENT '地址标签：家、公司等',
  `postcode` varchar(10) DEFAULT NULL COMMENT '邮政编码',
  `usage_count` int(11) DEFAULT 0 COMMENT '使用次数',
  `last_used_at` datetime DEFAULT NULL COMMENT '最后使用时间',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_user` (`user`),
  INDEX `idx_user_default` (`user`, `is_default`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.3 用户反馈表 (UserFeedback)

```sql
CREATE TABLE `user_feedback` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user` int(11) NOT NULL COMMENT '用户ID',
  `feedback_type` int(11) DEFAULT 1 COMMENT '反馈类型：1-留言，2-投诉，3-询问，4-售后，5-求购',
  `subject` varchar(100) NOT NULL COMMENT '主题',
  `content` text COMMENT '反馈内容',
  `file_urls` json DEFAULT NULL COMMENT '附件URLs',
  `status` tinyint(1) DEFAULT 0 COMMENT '状态：0-待处理，1-处理中，2-已解决，3-已关闭',
  `order_sn` varchar(50) DEFAULT NULL COMMENT '相关订单号',
  `admin_reply` text DEFAULT NULL COMMENT '管理员回复',
  `reply_at` datetime DEFAULT NULL COMMENT '回复时间',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `deleted_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_user` (`user`),
  INDEX `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.4 浏览历史表 (BrowsingHistory)

```sql
CREATE TABLE `browsing_history` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user` int(11) NOT NULL COMMENT '用户ID',
  `goods` int(11) NOT NULL COMMENT '商品ID',
  `source` varchar(50) DEFAULT NULL COMMENT '来源',
  `stay_time` int(11) DEFAULT 0 COMMENT '停留时间(秒)',
  `created_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_user_created` (`user`, `created_at`),
  INDEX `idx_goods` (`goods`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.5 用户偏好设置表 (UserPreferences)

```sql
CREATE TABLE `user_preferences` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user` int(11) NOT NULL COMMENT '用户ID',
  `preference_key` varchar(50) NOT NULL COMMENT '偏好键',
  `preference_value` text COMMENT '偏好值',
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_key` (`user`, `preference_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 4. API 接口说明

个人信息服务的主要 gRPC 接口包括：

### 4.1 商品收藏相关接口

```protobuf
// 获取用户收藏列表
rpc GetFavList(UserFavRequest) returns (UserFavListResponse);

// 添加收藏
rpc AddUserFav(UserFavRequest) returns (UserFavResponse);

// 删除收藏
rpc DeleteUserFav(UserFavRequest) returns (google.protobuf.Empty);

// 检查是否已收藏
rpc GetUserFavDetail(UserFavRequest) returns (UserFavDetailResponse);

// 批量获取收藏状态
rpc BatchGetUserFavStatus(BatchFavRequest) returns (BatchFavResponse);

// 更新收藏备注
rpc UpdateUserFavRemark(UpdateFavRemarkRequest) returns (google.protobuf.Empty);

// 设置价格变动提醒
rpc SetPriceNotification(PriceNotificationRequest) returns (google.protobuf.Empty);
```

### 3.2 地址管理相关接口

```protobuf
// 获取地址列表
rpc GetAddressList(AddressRequest) returns (AddressListResponse);

// 创建地址
rpc CreateAddress(AddressRequest) returns (AddressResponse);

// 删除地址
rpc DeleteAddress(AddressRequest) returns (google.protobuf.Empty);

// 更新地址
rpc UpdateAddress(AddressRequest) returns (google.protobuf.Empty);
```

### 3.3 用户留言相关接口

```protobuf
// 获取留言列表
rpc GetMessageList(MessageRequest) returns (MessageListResponse);

// 创建留言
rpc CreateMessage(MessageRequest) returns (MessageResponse);
```

## 4. 业务流程

### 4.1 商品收藏流程

1. 用户收藏商品

   - 检查商品是否存在
   - 检查用户是否已收藏该商品
   - 创建收藏记录

2. 用户取消收藏

   - 查询用户的收藏记录
   - 删除收藏记录

3. 用户查看收藏列表
   - 查询用户的收藏记录
   - 调用商品服务批量获取商品详情
   - 返回商品收藏列表

### 4.2 地址管理流程

1. 用户添加地址

   - 验证地址信息（省市区、手机号等）
   - 如果设置为默认地址，则将用户其他地址设为非默认
   - 创建地址记录

2. 用户更新地址

   - 验证地址信息
   - 如果设置为默认地址，则将用户其他地址设为非默认
   - 更新地址记录

3. 用户删除地址
   - 删除地址记录
   - 如果删除的是默认地址，可以自动将最新的地址设为默认

### 4.3 用户留言流程

1. 用户提交留言

   - 验证留言信息
   - 如果有附件，上传附件到对象存储
   - 创建留言记录

2. 用户查看留言列表
   - 查询用户的留言记录
   - 返回留言列表

## 5. 代码结构

个人信息服务采用整洁架构和领域驱动设计(DDD)原则，代码结构如下：

```
backend/profile/
├── cmd/                # 应用入口
│   └── main.go         # 服务启动入口
├── configs/            # 服务特定配置
│   ├── config.go       # 配置加载
│   └── config.yaml     # 配置文件
├── api/                # API定义
│   ├── common/         # 通用定义
│   └── proto/          # Protocol Buffers
│       └── profile.proto # 个人信息服务接口定义
├── internal/           # 内部实现
│   ├── domain/         # 领域模型
│   │   ├── entity/     # 实体定义
│   │   │   ├── userfav.go  # 收藏实体
│   │   │   ├── address.go  # 地址实体
│   │   │   └── message.go  # 留言实体
│   │   └── valueobject/  # 值对象
│   │       └── address_info.go # 地址值对象
│   ├── repository/     # 数据仓储层
│   │   ├── userfav_repository.go   # 收藏仓储接口
│   │   ├── userfav_repository_impl.go # 收藏仓储实现
│   │   ├── address_repository.go   # 地址仓储接口
│   │   ├── address_repository_impl.go # 地址仓储实现
│   │   ├── message_repository.go   # 留言仓储接口
│   │   ├── message_repository_impl.go # 留言仓储实现
│   │   ├── cache/      # 缓存实现
│   │   │   └── redis_cache.go # Redis缓存
│   │   └── dao/        # 数据访问对象
│   │       ├── userfav_dao.go  # 收藏DAO
│   │       ├── address_dao.go  # 地址DAO
│   │       └── message_dao.go  # 留言DAO
│   ├── service/        # 业务服务层
│   │   ├── userfav_service.go    # 收藏服务接口
│   │   ├── userfav_service_impl.go # 收藏服务实现
│   │   ├── address_service.go    # 地址服务接口
│   │   ├── address_service_impl.go # 地址服务实现
│   │   ├── message_service.go    # 留言服务接口
│   │   └── message_service_impl.go # 留言服务实现
│   └── web/            # Web交互层
│       ├── grpc/       # gRPC服务实现
│       │   └── profile_grpc_handler.go # gRPC处理器
│       └── http/       # HTTP服务实现
│           ├── userfav_handler.go  # 收藏API处理器
│           ├── address_handler.go  # 地址API处理器
│           └── message_handler.go  # 留言API处理器
├── pkg/                # 服务内共享包
│   ├── util/           # 通用工具
│   │   └── validator.go  # 数据验证工具
│   ├── middleware/     # 中间件
│   │   └── ratelimit/  # 限流
│   │       └── limiter.go  # 限流器
│   └── client/         # 外部服务客户端
│       ├── user_client.go  # 用户服务客户端
│       └── product_client.go  # 商品服务客户端
└── script/             # 脚本文件
    └── mysql/          # 数据库脚本
        ├── schema.sql  # 表结构
        └── migrations/  # 数据库迁移
```

## 6. 技术栈实现

个人信息服务集成了多种现代技术栈，以提供高性能、高可用的服务：

### 6.1 gRPC 通信

个人信息服务使用 gRPC 作为微服务间通信的主要方式：

- 通过 Protocol Buffers 定义服务接口，实现强类型的接口通信
- 使用拦截器实现统一的日志记录、认证、限流等功能
- 支持客户端负载均衡，通过服务发现自动分发请求到不同实例
- 提供高性能的双向流通信，支持服务端推送更新

```go
// 示例：gRPC 服务器创建
func NewGrpcServer(addr string, profileService service.ProfileService, logger *zap.Logger) error {
    // 创建 gRPC 服务器
    server := grpc.NewServer(
        grpc.ChainUnaryInterceptor(
            // 日志记录拦截器
            func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
                start := time.Now()
                resp, err := handler(ctx, req)
                logger.Info("gRPC call",
                    zap.String("method", info.FullMethod),
                    zap.Duration("duration", time.Since(start)),
                    zap.Error(err),
                )
                return resp, err
            },
            // 认证拦截器
            func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok {
                    return nil, status.Error(codes.Unauthenticated, "missing metadata")
                }

                tokens := md.Get("authorization")
                if len(tokens) == 0 {
                    return nil, status.Error(codes.Unauthenticated, "missing token")
                }

                // token验证逻辑省略...

                return handler(ctx, req)
            },
        ),
    )

    // 注册个人信息服务
    pb.RegisterProfileServiceServer(server, &ProfileServiceServer{Service: profileService})

    // 启动 gRPC 服务器
    lis, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }

    return server.Serve(lis)
}
```

### 6.2 MongoDB 存储

个人信息服务使用 MongoDB 存储非关系型数据，特别是用户收藏和留言信息：

- 灵活的文档模型，适合存储结构多变的用户留言
- 高效的查询能力，支持地理位置查询用户地址
- 强大的聚合框架，便于分析用户行为数据
- 原生支持分布式部署，实现高可用性

```go
// 示例：MongoDB 用户留言存储
type MessageRepository struct {
    client     *mongo.Client
    database   string
    collection string
    logger     *zap.Logger
}

func NewMessageRepository(client *mongo.Client, database, collection string, logger *zap.Logger) *MessageRepository {
    return &MessageRepository{
        client:     client,
        database:   database,
        collection: collection,
        logger:     logger,
    }
}

// 创建用户留言
func (r *MessageRepository) CreateMessage(ctx context.Context, message *entity.Message) error {
    coll := r.client.Database(r.database).Collection(r.collection)

    doc := bson.M{
        "user_id":     message.UserID,
        "content":     message.Content,
        "message_type": message.MessageType,
        "status":      message.Status,
        "images":      message.Images,
        "created_at":  message.CreatedAt,
        "updated_at":  message.UpdatedAt,
    }

    result, err := coll.InsertOne(ctx, doc)
    if err != nil {
        r.logger.Error("Failed to insert message", zap.Error(err))
        return err
    }

    // 设置 ID
    if oid, ok := result.InsertedID.(primitive.ObjectID); ok {
        message.ID = oid.Hex()
    }

    return nil
}

// 获取用户留言列表
func (r *MessageRepository) GetMessagesByUserID(ctx context.Context, userID int64, page, pageSize int) ([]*entity.Message, int64, error) {
    coll := r.client.Database(r.database).Collection(r.collection)

    filter := bson.M{"user_id": userID}

    // 计算总数
    total, err := coll.CountDocuments(ctx, filter)
    if err != nil {
        r.logger.Error("Failed to count messages", zap.Error(err), zap.Int64("user_id", userID))
        return nil, 0, err
    }

    // 查询消息
    options := options.Find().
        SetSort(bson.M{"created_at": -1}).
        SetSkip(int64((page - 1) * pageSize)).
        SetLimit(int64(pageSize))

    cursor, err := coll.Find(ctx, filter, options)
    if err != nil {
        r.logger.Error("Failed to find messages", zap.Error(err), zap.Int64("user_id", userID))
        return nil, 0, err
    }
    defer cursor.Close(ctx)

    messages := make([]*entity.Message, 0)
    for cursor.Next(ctx) {
        var doc bson.M
        if err := cursor.Decode(&doc); err != nil {
            r.logger.Error("Failed to decode message", zap.Error(err))
            continue
        }

        message := &entity.Message{
            ID:          doc["_id"].(primitive.ObjectID).Hex(),
            UserID:      doc["user_id"].(int64),
            Content:     doc["content"].(string),
            MessageType: doc["message_type"].(int),
            Status:      doc["status"].(int),
            Images:      make([]string, 0),
            CreatedAt:   doc["created_at"].(time.Time),
        }

        if images, ok := doc["images"].(primitive.A); ok {
            for _, img := range images {
                message.Images = append(message.Images, img.(string))
            }
        }

        if updatedAt, ok := doc["updated_at"].(time.Time); ok {
            message.UpdatedAt = updatedAt
        }

        messages = append(messages, message)
    }

    return messages, total, nil
}
```

### 6.3 Consul 服务发现

个人信息服务使用 Consul 实现服务注册与发现：

- 自动注册服务实例，支持多实例负载均衡
- 健康检查机制确保只有健康的实例接收流量
- 使用 KV 存储实现分布式配置和分布式锁
- 支持多数据中心部署，提高服务的容灾能力

```go
// 示例：Consul 服务注册
func RegisterService(config *Config) error {
    // 创建 Consul 客户端
    consulConfig := consulapi.DefaultConfig()
    consulConfig.Address = config.Consul.Address

    client, err := consulapi.NewClient(consulConfig)
    if err != nil {
        return fmt.Errorf("create consul client failed: %w", err)
    }

    // 服务注册
    registration := &consulapi.AgentServiceRegistration{
        ID:      fmt.Sprintf("profile-service-%s-%d", config.Server.Host, config.Server.Port),
        Name:    "profile-service",
        Address: config.Server.Host,
        Port:    config.Server.Port,
        Tags:    []string{"profile", "api", "grpc"},
        Check: &consulapi.AgentServiceCheck{
            GRPC:                           fmt.Sprintf("%s:%d/%s", config.Server.Host, config.Server.Port, "health"),
            Interval:                       "10s",
            Timeout:                        "5s",
            DeregisterCriticalServiceAfter: "30s",
        },
    }

    if err := client.Agent().ServiceRegister(registration); err != nil {
        return fmt.Errorf("register service failed: %w", err)
    }

    // 设置关闭时注销服务
    sigs := make(chan os.Signal, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sigs
        client.Agent().ServiceDeregister(registration.ID)
        os.Exit(0)
    }()

    return nil
}
```

### 6.4 Nacos 配置中心

个人信息服务使用 Nacos 作为配置中心，实现配置的集中管理：

- 支持动态配置管理，配置变更实时生效
- 配置变更历史记录和版本管理
- 支持环境和命名空间隔离，便于多环境部署
- 集成配置监听，自动响应配置变更

```go
// 示例：从 Nacos 加载配置
func LoadConfigFromNacos() (*Config, error) {
    // 创建ServerConfig
    sc := []constant.ServerConfig{
        {
            IpAddr: "nacos-server",
            Port:   8848,
        },
    }

    // 创建ClientConfig
    cc := constant.ClientConfig{
        NamespaceId:         "profile-service",
        TimeoutMs:           5000,
        NotLoadCacheAtStart: true,
        LogLevel:            "error",
    }

    // 创建动态配置客户端
    client, err := clients.CreateConfigClient(map[string]interface{}{
        "serverConfigs": sc,
        "clientConfig":  cc,
    })
    if err != nil {
        return nil, fmt.Errorf("create nacos config client failed: %w", err)
    }

    // 获取配置
    content, err := client.GetConfig(vo.ConfigParam{
        DataId: "profile-service.yaml",
        Group:  "DEFAULT_GROUP",
    })
    if err != nil {
        return nil, fmt.Errorf("get config from nacos failed: %w", err)
    }

    // 解析配置
    var config Config
    if err := yaml.Unmarshal([]byte(content), &config); err != nil {
        return nil, fmt.Errorf("unmarshal config failed: %w", err)
    }

    // 监听配置变化
    client.ListenConfig(vo.ConfigParam{
        DataId: "profile-service.yaml",
        Group:  "DEFAULT_GROUP",
        OnChange: func(namespace, group, dataId, data string) {
            var newConfig Config
            if err := yaml.Unmarshal([]byte(data), &newConfig); err != nil {
                log.Printf("Failed to parse updated config: %v", err)
                return
            }

            // 应用新配置（实际应用需考虑并发安全）
            updateConfig(&newConfig)
        },
    })

    return &config, nil
}
```

### 6.5 Swagger API 文档

个人信息服务通过 Swagger 实现 API 文档的自动生成：

- 从代码注释自动生成 API 文档
- 提供在线 API 测试功能
- 版本管理和变更历史记录
- 多种导出格式支持（JSON、YAML、HTML）

```go
// 示例：Swagger 注解
// @Summary 创建收藏
// @Description 用户添加商品收藏
// @Tags 用户收藏
// @Accept json
// @Produce json
// @Param Authorization header string true "用户令牌"
// @Param AddFavRequest body AddFavRequest true "收藏请求"
// @Success 200 {object} Response
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /api/v1/profile/favs [post]
func (h *FavHandler) AddUserFav(c *gin.Context) {
    // 获取用户ID
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "用户未认证"})
        return
    }

    var req AddFavRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": err.Error()})
        return
    }

    // 调用服务添加收藏
    err := h.userFavService.AddUserFav(c.Request.Context(), userID.(int64), req.GoodsID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"code": 200, "message": "收藏成功"})
}
```

### 6.6 Zap 日志系统

个人信息服务使用 Zap 实现高性能日志记录：

- 提供结构化日志格式，便于日志分析
- 高性能设计，对服务性能影响最小
- 支持多级别日志和采样控制
- 与 ELK 等日志系统无缝集成

```go
// 示例：Zap 日志配置
func NewLogger(config *Config) (*zap.Logger, error) {
    // 基础配置
    cfg := zap.Config{
        Level:       zap.NewAtomicLevelAt(getLogLevel(config.Log.Level)),
        Development: config.Env == "development",
        Encoding:    "json",
        EncoderConfig: zapcore.EncoderConfig{
            TimeKey:        "timestamp",
            LevelKey:       "level",
            NameKey:        "logger",
            CallerKey:      "caller",
            FunctionKey:    zapcore.OmitKey,
            MessageKey:     "message",
            StacktraceKey:  "stacktrace",
            LineEnding:     zapcore.DefaultLineEnding,
            EncodeLevel:    zapcore.LowercaseLevelEncoder,
            EncodeTime:     zapcore.ISO8601TimeEncoder,
            EncodeDuration: zapcore.SecondsDurationEncoder,
            EncodeCaller:   zapcore.ShortCallerEncoder,
        },
        OutputPaths:      []string{config.Log.Path, "stdout"},
        ErrorOutputPaths: []string{config.Log.ErrorPath},
    }

    // 创建日志器
    logger, err := cfg.Build(
        zap.Fields(
            zap.String("service", "profile-service"),
            zap.String("version", "1.0.0"),
        ),
    )
    if err != nil {
        return nil, err
    }

    // 替换全局Logger
    zap.ReplaceGlobals(logger)

    return logger, nil
}

// 获取日志级别
func getLogLevel(level string) zapcore.Level {
    switch strings.ToLower(level) {
    case "debug":
        return zap.DebugLevel
    case "info":
        return zap.InfoLevel
    case "warn":
        return zap.WarnLevel
    case "error":
        return zap.ErrorLevel
    default:
        return zap.InfoLevel
    }
}
```

### 6.7 Nginx 反向代理

个人信息服务通过 Nginx 作为 API 网关和负载均衡器：

- 请求路由转发到用户操作服务实例
- 静态资源缓存和压缩，提高访问速度
- SSL 终止和 HTTPS 支持
- 请求限流和访问控制

```nginx
# Nginx 配置示例
upstream profile_service {
    server profile-service-1:8080;
    server profile-service-2:8080;
    server profile-service-3:8080;
    keepalive 32;
}

server {
    listen 443 ssl http2;
    server_name api.shop.example.com;

    ssl_certificate     /etc/nginx/certs/api.shop.example.com.crt;
    ssl_certificate_key /etc/nginx/certs/api.shop.example.com.key;

    # 个人信息API
    location /api/v1/profile/ {
        # 限流配置
        limit_req zone=api burst=20 nodelay;

        # CORS 支持
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type';

        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # 转发到个人信息服务
        proxy_pass http://profile_service;
        proxy_http_version 1.1;
        proxy_set_header Connection '';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 超时设置
        proxy_connect_timeout 5s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }

    # Swagger 文档
    location /api/v1/profile/docs {
        proxy_pass http://profile_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

## 8. 数据一致性

个人信息服务涉及到与商品服务、用户服务等多个微服务的数据协调，需要特别关注数据一致性问题。

### 8.1 跨服务数据一致性

个人信息服务采用了多种策略保证跨服务数据一致性：

1. **最终一致性模式**：使用事件驱动架构，通过消息队列实现数据的最终一致性
2. **定时对账**：定期与其他服务同步数据，修复不一致问题
3. **数据版本控制**：使用版本号或时间戳检测和解决数据冲突

```go
// 商品信息同步示例
func (s *userFavService) SyncProductInfo(ctx context.Context) error {
    // 获取所有收藏商品ID
    favs, err := s.repo.GetAllUserFavs(ctx)
    if err != nil {
        return err
    }

    // 提取商品ID
    var goodsIds []int64
    for _, fav := range favs {
        goodsIds = append(goodsIds, fav.Goods)
    }

    // 批量获取商品信息
    if len(goodsIds) > 0 {
        goodsInfos, err := s.productClient.BatchGetGoods(ctx, &product.BatchGoodsIdInfo{
            Id: goodsIds,
        })
        if err != nil {
            s.logger.Error("Failed to get product info", zap.Error(err))
            return err
        }

        // 更新收藏的商品信息缓存
        for _, goods := range goodsInfos.GoodsList {
            cacheKey := fmt.Sprintf("product_info:%d", goods.Id)
            s.redisClient.Set(ctx, cacheKey, goods, 24*time.Hour)

            // 检查价格变动
            s.checkPriceChanges(ctx, goods)
        }
    }

    return nil
}
```

### 8.2 高并发一致性保障

在高并发场景下，个人信息服务采用以下措施确保数据一致性：

1. **乐观锁**：使用版本号控制并发更新
2. **分布式锁**：关键操作使用 Redis 分布式锁避免并发冲突
3. **幂等设计**：所有 API 接口实现幂等性，避免重复操作导致数据不一致

```go
// 地址更新幂等性实现示例
func (s *addressService) UpdateAddress(ctx context.Context, req *proto.AddressRequest) (*proto.AddressResponse, error) {
    // 生成操作ID，用于幂等性控制
    operationID := req.GetRequestId()
    if operationID == "" {
        operationID = uuid.New().String()
    }

    // 检查操作是否已执行
    cacheKey := fmt.Sprintf("address_update:%s", operationID)
    if exists, _ := s.redisClient.Exists(ctx, cacheKey).Result(); exists > 0 {
        // 操作已执行，直接返回成功
        resp, err := s.redisClient.Get(ctx, cacheKey).Result()
        if err == nil && resp != "" {
            var address proto.AddressResponse
            if err := json.Unmarshal([]byte(resp), &address); err == nil {
                return &address, nil
            }
        }
    }

    // 执行实际更新操作...

    // 记录操作结果，有效期30分钟
    if updatedAddress != nil {
        addressJson, _ := json.Marshal(updatedAddress)
        s.redisClient.Set(ctx, cacheKey, addressJson, 30*time.Minute)
    }

    return updatedAddress, nil
}
```

### 8.3 缓存一致性保障

个人信息服务大量使用缓存提升性能，为保障缓存与数据库的一致性，采用以下策略：

1. **缓存更新策略**：采用 Cache-Aside 模式，先更新数据库，再更新缓存
2. **缓存过期机制**：所有缓存设置合理的过期时间，避免长期不一致
3. **双删策略**：在某些关键场景使用"先删缓存-更新数据库-再删缓存"的双删策略
4. **异步更新机制**：非关键数据采用异步方式更新缓存，减少响应延迟

## 9. 隐私保护机制

个人信息服务处理大量用户隐私数据，实现了全面的隐私保护机制。

### 9.1 数据脱敏

对敏感个人信息进行自动脱敏处理：

1. **地址信息脱敏**：对外展示时隐藏详细门牌号
2. **联系电话脱敏**：仅显示前三位和后四位，中间使用星号代替
3. **用户反馈脱敏**：自动检测并屏蔽反馈中的敏感信息（如身份证号、银行卡号等）

```go
// 电话号码脱敏示例
func MaskPhoneNumber(phone string) string {
    if len(phone) != 11 {
        return phone // 非标准手机号不处理
    }
    return phone[:3] + "****" + phone[7:]
}

// 地址脱敏
func MaskAddress(address string) string {
    if address == "" {
        return ""
    }

    parts := strings.Split(address, " ")
    if len(parts) <= 1 {
        return address // 简单地址不处理
    }

    // 保留省市区等行政区划，脱敏具体门牌号
    if len(parts) >= 3 {
        parts[len(parts)-1] = "****"
        return strings.Join(parts, " ")
    }

    return address
}
```

### 9.2 数据访问控制

严格的数据访问控制机制：

1. **基于角色的访问控制**：不同角色有不同的数据访问权限
2. **操作审计日志**：记录所有敏感数据的访问和操作
3. **数据访问阈值控制**：限制批量查询数量，防止批量数据泄露

```go
// 操作审计日志记录
func (s *profileService) recordAccessLog(ctx context.Context, operation string, resourceType string, resourceID string) {
    // 从上下文中获取用户信息
    userID := extractUserID(ctx)
    clientIP := extractClientIP(ctx)

    // 记录审计日志
    log := &model.AccessLog{
        UserID:       userID,
        Operation:    operation,
        ResourceType: resourceType,
        ResourceID:   resourceID,
        ClientIP:     clientIP,
        AccessTime:   time.Now(),
    }

    // 异步写入日志，不阻塞主流程
    go func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.logRepo.CreateAccessLog(ctx, log); err != nil {
            s.logger.Error("Failed to record access log", zap.Error(err))
        }
    }()
}
```

### 9.3 数据生命周期管理

个人信息服务实现了完整的数据生命周期管理：

1. **数据收集最小化**：只收集必要的个人信息
2. **使用期限控制**：明确数据使用期限，超期自动删除或匿名化
3. **用户数据导出**：支持用户导出个人数据
4. **彻底删除机制**：用户注销账号时彻底删除个人数据

```go
// 数据清理任务示例
func (s *cleanupService) cleanupExpiredData(ctx context.Context) error {
    // 清理长期未使用的地址
    expiredTime := time.Now().AddDate(0, -6, 0) // 6个月未使用
    if err := s.addressRepo.AnonymizeInactiveAddresses(ctx, expiredTime); err != nil {
        s.logger.Error("Failed to anonymize inactive addresses", zap.Error(err))
    }

    // 清理过期的浏览历史
    historyExpireTime := time.Now().AddDate(0, -3, 0) // 3个月前的浏览记录
    if err := s.historyRepo.DeleteExpiredHistory(ctx, historyExpireTime); err != nil {
        s.logger.Error("Failed to delete expired browsing history", zap.Error(err))
    }

    // 清理已关闭的用户反馈
    feedbackExpireTime := time.Now().AddDate(0, -12, 0) // 12个月前的已关闭反馈
    if err := s.feedbackRepo.ArchiveOldFeedback(ctx, feedbackExpireTime); err != nil {
        s.logger.Error("Failed to archive old feedback", zap.Error(err))
    }

    return nil
}
```

### 9.4 合规性支持

个人信息服务提供完整的隐私合规支持：

1. **隐私政策支持**：系统行为符合隐私政策声明
2. **用户同意管理**：记录用户对隐私政策的同意状态
3. **用户权益保障**：支持"被遗忘权"、"数据可携带权"等用户数据权益
